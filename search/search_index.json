{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":"<p>\ufe0f\ud83c\udf9e Subtitles generation tool (Web-UI + CLI + Python package) powered by OpenAI's Whisper and its variants \ud83c\udf9e\ufe0f</p>"},{"location":"#subsai.main","title":"subsai.main","text":"<p>SubsAI: Subtitles AI Subtitles generation tool powered by OpenAI's Whisper and its variants.</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.</p>"},{"location":"#subsai.main.SubsAI","title":"SubsAI","text":"<p>Subs AI class</p> <p>Example usage: <pre><code>file = './assets/test1.mp4'\nsubs_ai = SubsAI()\nmodel = subs_ai.create_model('openai/whisper', {'model_type': 'base'})\nsubs = subs_ai.transcribe(file, model)\nsubs.save('test1.srt')\n</code></pre></p>"},{"location":"#subsai.main.SubsAI.available_models","title":"available_models  <code>staticmethod</code>","text":"<pre><code>available_models()\n</code></pre> <p>Returns the supported models</p> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>list of available models</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef available_models() -&gt; list:\n    \"\"\"\n    Returns the supported models\n\n    :return: list of available models\n    \"\"\"\n    return list(AVAILABLE_MODELS.keys())\n</code></pre>"},{"location":"#subsai.main.SubsAI.model_info","title":"model_info  <code>staticmethod</code>","text":"<pre><code>model_info(model)\n</code></pre> <p>Returns general infos about the model (brief description and url)</p> <p>Parameters:</p> <ul> <li> <code>model</code>             (<code>str</code>)         \u2013          <p>model name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>dict of infos</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef model_info(model: str) -&gt; dict:\n    \"\"\"\n    Returns general infos about the model (brief description and url)\n\n    :param model: model name\n\n    :return: dict of infos\n    \"\"\"\n    return {'description': AVAILABLE_MODELS[model]['description'],\n            'url': AVAILABLE_MODELS[model]['url']}\n</code></pre>"},{"location":"#subsai.main.SubsAI.config_schema","title":"config_schema  <code>staticmethod</code>","text":"<pre><code>config_schema(model)\n</code></pre> <p>Returns the configs associated with a model</p> <p>Parameters:</p> <ul> <li> <code>model</code>             (<code>str</code>)         \u2013          <p>model name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>dict of configs</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef config_schema(model: str) -&gt; dict:\n    \"\"\"\n    Returns the configs associated with a model\n\n    :param model: model name\n\n    :return: dict of configs\n    \"\"\"\n    return AVAILABLE_MODELS[model]['config_schema']\n</code></pre>"},{"location":"#subsai.main.SubsAI.create_model","title":"create_model  <code>staticmethod</code>","text":"<pre><code>create_model(model_name, model_config={})\n</code></pre> <p>Returns a model instance</p> <p>Parameters:</p> <ul> <li> <code>model_name</code>             (<code>str</code>)         \u2013          <p>the name of the model</p> </li> <li> <code>model_config</code>             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>the configuration dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractModel</code>         \u2013          <p>the model instance</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef create_model(model_name: str, model_config: dict = {}) -&gt; AbstractModel:\n    \"\"\"\n    Returns a model instance\n\n    :param model_name: the name of the model\n    :param model_config: the configuration dict\n\n    :return: the model instance\n    \"\"\"\n    return AVAILABLE_MODELS[model_name]['class'](model_config)\n</code></pre>"},{"location":"#subsai.main.SubsAI.transcribe","title":"transcribe  <code>staticmethod</code>","text":"<pre><code>transcribe(media_file, model, model_config={})\n</code></pre> <p>Takes the model instance (created by :func:<code>create_model</code>) or the model name. Returns a :class:<code>pysubs2.SSAFile</code> https://pysubs2.readthedocs.io/en/latest/api-reference.html#ssafile-a-subtitle-file`_</p> <p>Parameters:</p> <ul> <li> <code>media_file</code>             (<code>str</code>)         \u2013          <p>path of the media file (video/audio)</p> </li> <li> <code>model</code>             (<code>Union[AbstractModel, str]</code>)         \u2013          <p>model instance or model name</p> </li> <li> <code>model_config</code>             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>model configs' dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>         \u2013          <p>SSAFile: list of subtitles</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef transcribe(media_file: str, model: Union[AbstractModel, str], model_config: dict = {}) -&gt; SSAFile:\n    \"\"\"\n    Takes the model instance (created by :func:`create_model`) or the model name.\n    Returns a :class:`pysubs2.SSAFile` &lt;https://pysubs2.readthedocs.io/en/latest/api-reference.html#ssafile-a-subtitle-file&gt;`_\n\n    :param media_file: path of the media file (video/audio)\n    :param model: model instance or model name\n    :param model_config: model configs' dict\n\n    :return: SSAFile: list of subtitles\n    \"\"\"\n    if type(model) == str:\n        stt_model = SubsAI.create_model(model, model_config)\n    else:\n        stt_model = model\n    media_file = str(pathlib.Path(media_file).resolve())\n    return stt_model.transcribe(media_file)\n</code></pre>"},{"location":"#subsai.main.Tools","title":"Tools","text":"<pre><code>Tools()\n</code></pre> <p>Some tools related to subtitles processing (ex: translation)</p> Source code in <code>src/subsai/main.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"#subsai.main.Tools.available_translation_models","title":"available_translation_models  <code>staticmethod</code>","text":"<pre><code>available_translation_models()\n</code></pre> <p>Returns available translation models A simple link to :func:<code>utils.available_translation_models</code> for easy access</p> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>list of available models</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef available_translation_models() -&gt; list:\n    \"\"\"\n    Returns available translation models\n    A simple link to :func:`utils.available_translation_models` for easy access\n\n    :return: list of available models\n    \"\"\"\n\n    return available_translation_models()\n</code></pre>"},{"location":"#subsai.main.Tools.available_translation_languages","title":"available_translation_languages  <code>staticmethod</code>","text":"<pre><code>available_translation_languages(model)\n</code></pre> <p>Returns the languages supported by the translation model</p> <p>Parameters:</p> <ul> <li> <code>model</code>             (<code>Union[str, TranslationModel]</code>)         \u2013          <p>the name of the model</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>list of available languages</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef available_translation_languages(model: Union[str, TranslationModel]) -&gt; list:\n    \"\"\"\n    Returns the languages supported by the translation model\n\n    :param model: the name of the model\n    :return: list of available languages\n    \"\"\"\n    if type(model) == str:\n        langs = Tools.create_translation_model(model).available_languages()\n    else:\n        langs = model.available_languages()\n    return langs\n</code></pre>"},{"location":"#subsai.main.Tools.create_translation_model","title":"create_translation_model  <code>staticmethod</code>","text":"<pre><code>create_translation_model(\n    model_name=\"m2m100\", model_family=None\n)\n</code></pre> <p>Creates and returns a translation model instance.</p> <p>Parameters:</p> <ul> <li> <code>model_name</code>             (<code>str</code>, default:                 <code>'m2m100'</code> )         \u2013          <p>name of the model. To get available models use :func:<code>available_translation_models</code></p> </li> <li> <code>model_family</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>Either \"mbart50\" or \"m2m100\". By default, See <code>dl-translate</code> docs</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TranslationModel</code>         \u2013          <p>A translation model instance</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef create_translation_model(model_name: str = \"m2m100\", model_family: str = None) -&gt; TranslationModel:\n    \"\"\"\n    Creates and returns a translation model instance.\n\n    :param model_name: name of the model. To get available models use :func:`available_translation_models`\n    :param model_family: Either \"mbart50\" or \"m2m100\". By default, See `dl-translate` docs\n    :return: A translation model instance\n    \"\"\"\n    mt = TranslationModel(model_or_path=model_name, model_family=model_family)\n    return mt\n</code></pre>"},{"location":"#subsai.main.Tools.translate","title":"translate  <code>staticmethod</code>","text":"<pre><code>translate(\n    subs,\n    source_language,\n    target_language,\n    model=\"m2m100\",\n    model_family=None,\n    translation_configs={},\n)\n</code></pre> <p>Translates a subtitles <code>SSAFile</code> object, what :func:<code>SubsAI.transcribe</code> is returning</p> <p>Parameters:</p> <ul> <li> <code>subs</code>             (<code>SSAFile</code>)         \u2013          <p><code>SSAFile</code> object</p> </li> <li> <code>source_language</code>             (<code>str</code>)         \u2013          <p>the language of the subtitles</p> </li> <li> <code>target_language</code>             (<code>str</code>)         \u2013          <p>the target language</p> </li> <li> <code>model</code>             (<code>Union[str, TranslationModel]</code>, default:                 <code>'m2m100'</code> )         \u2013          <p>the translation model, either an <code>str</code> or the model instance created by :func:<code>create_translation_model</code></p> </li> <li> <code>model_family</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>Either \"mbart50\" or \"m2m100\". By default, See <code>dl-translate</code> docs</p> </li> <li> <code>translation_configs</code>             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>dict of translation configs (see :attr:<code>configs.ADVANCED_TOOLS_CONFIGS</code>)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>         \u2013          <p>returns an <code>SSAFile</code> subtitles translated to the target language</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef translate(subs: SSAFile,\n              source_language: str,\n              target_language: str,\n              model: Union[str, TranslationModel] = \"m2m100\",\n              model_family: str = None,\n              translation_configs: dict = {}) -&gt; SSAFile:\n    \"\"\"\n    Translates a subtitles `SSAFile` object, what :func:`SubsAI.transcribe` is returning\n\n    :param subs: `SSAFile` object\n    :param source_language: the language of the subtitles\n    :param target_language: the target language\n    :param model: the translation model, either an `str` or the model instance created by\n                    :func:`create_translation_model`\n    :param model_family: Either \"mbart50\" or \"m2m100\". By default, See `dl-translate` docs\n    :param translation_configs: dict of translation configs (see :attr:`configs.ADVANCED_TOOLS_CONFIGS`)\n\n    :return: returns an `SSAFile` subtitles translated to the target language\n    \"\"\"\n    if type(model) == str:\n        translation_model = Tools.create_translation_model(model_name=model, model_family=model_family)\n    else:\n        translation_model = model\n\n    translated_subs = SSAFile()\n    for sub in subs:\n        translated_sub = sub.copy()\n        translated_sub.text = translation_model.translate(text=sub.text,\n                                                          source=source_language,\n                                                          target=target_language,\n                                                          batch_size=translation_configs[\n                                                              'batch_size'] if 'batch_size' in translation_configs else 32,\n                                                          verbose=translation_configs[\n                                                              'verbose'] if 'verbose' in translation_configs else False)\n        translated_subs.append(translated_sub)\n    return translated_subs\n</code></pre>"},{"location":"#subsai.main.Tools.auto_sync","title":"auto_sync  <code>staticmethod</code>","text":"<pre><code>auto_sync(subs, media_file, **kwargs)\n</code></pre> <p>Uses (ffsubsync)[https://github.com/smacke/ffsubsync] to auto-sync subtitles to the media file</p> <p>Parameters:</p> <ul> <li> <code>subs</code>             (<code>SSAFile</code>)         \u2013          <p><code>SSAFile</code> file</p> </li> <li> <code>media_file</code>             (<code>str</code>)         \u2013          <p>path of the media_file</p> </li> <li> <code>kwargs</code>         \u2013          <p>configs to pass to ffsubsync (see :attr:<code>configs.ADVANCED_TOOLS_CONFIGS</code>)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>         \u2013          <p><code>SSAFile</code> auto-synced</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef auto_sync(subs: SSAFile,\n              media_file: str,\n              **kwargs\n              ) -&gt; SSAFile:\n    \"\"\"\n    Uses (ffsubsync)[https://github.com/smacke/ffsubsync] to auto-sync subtitles to the media file\n\n    :param subs: `SSAFile` file\n    :param media_file: path of the media_file\n    :param kwargs: configs to pass to ffsubsync (see :attr:`configs.ADVANCED_TOOLS_CONFIGS`)\n\n    :return: `SSAFile` auto-synced\n    \"\"\"\n    parser = make_parser()\n    srtin_file = tempfile.NamedTemporaryFile(delete=False)\n    srtout_file = tempfile.NamedTemporaryFile(delete=False)\n    try:\n        srtin = srtin_file.name + '.ass'\n        srtout = srtout_file.name + '.srt'\n        subs.save(srtin)\n        cmd = [media_file,\n               '-i', srtin,\n               '-o', srtout]\n        for config_name in kwargs:\n            value = kwargs[config_name]\n            if value is None or value is False:\n                continue\n            elif type(value) == bool and value is True:\n                cmd.append(f'--{config_name}')\n            else:\n                cmd.append(f'--{config_name}')\n                cmd.append(f'{value}')\n        parsed_args = parser.parse_args(cmd)\n        retval = run(parsed_args)[\"retval\"]\n        synced_subs = pysubs2.load(srtout)\n        return synced_subs\n    finally:\n        srtin_file.close()\n        os.unlink(srtin_file.name)\n        srtout_file.close()\n        os.unlink(srtout_file.name)\n</code></pre>"},{"location":"#subsai.main.Tools.merge_subs_with_video","title":"merge_subs_with_video  <code>staticmethod</code>","text":"<pre><code>merge_subs_with_video(\n    subs, media_file, output_filename=None, **kwargs\n)\n</code></pre> <p>Uses ffmpeg to merge subtitles into a video media file. You cna merge multiple subs at the same time providing a dict with (lang,<code>SSAFile</code> object) key,value pairs Example: <pre><code>    file = '../../assets/video/test1.webm'\n    subs_ai = SubsAI()\n    model = subs_ai.create_model('openai/whisper', {'model_type': 'tiny'})\n    en_subs = subs_ai.transcribe(file, model)\n    ar_subs = pysubs2.load('../../assets/video/test0-ar.srt')\n    Tools.merge_subs_with_video2({'English': subs, \"Arabic\": subs2}, file)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>subs</code>             (<code>Dict[str, SSAFile]</code>)         \u2013          <p>dict with (lang,<code>SSAFile</code> object) key,value pairs</p> </li> <li> <code>media_file</code>             (<code>str</code>)         \u2013          <p>path of the video media_file</p> </li> <li> <code>output_filename</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>Output file name (without the extension as it will be inferred from the media file)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>Absolute path of the output file</p> </li> </ul> Source code in <code>src/subsai/main.py</code> <pre><code>@staticmethod\ndef merge_subs_with_video(subs: Dict[str, SSAFile],\n              media_file: str,\n              output_filename: str = None,\n              **kwargs\n              ) -&gt; str:\n    \"\"\"\n    Uses ffmpeg to merge subtitles into a video media file.\n    You cna merge multiple subs at the same time providing a dict with (lang,`SSAFile` object) key,value pairs\n    Example:\n    ```python\n        file = '../../assets/video/test1.webm'\n        subs_ai = SubsAI()\n        model = subs_ai.create_model('openai/whisper', {'model_type': 'tiny'})\n        en_subs = subs_ai.transcribe(file, model)\n        ar_subs = pysubs2.load('../../assets/video/test0-ar.srt')\n        Tools.merge_subs_with_video2({'English': subs, \"Arabic\": subs2}, file)\n    ```\n\n    :param subs: dict with (lang,`SSAFile` object) key,value pairs\n    :param media_file: path of the video media_file\n    :param output_filename: Output file name (without the extension as it will be inferred from the media file)\n\n    :return: Absolute path of the output file\n    \"\"\"\n    metadata = ffmpeg.probe(media_file, select_streams=\"v\")['streams'][0]\n    assert metadata['codec_type'] == 'video', f'File {media_file} is not a video'\n\n\n    srtin_files = {key: tempfile.NamedTemporaryFile(delete=False) for key in subs}\n    try:\n        in_file = pathlib.Path(media_file)\n        if output_filename is not None:\n            out_file = in_file.parent / f\"{output_filename}{in_file.suffix}\"\n        else:\n            out_file = in_file.parent / f\"{in_file.stem}-subs-merged{in_file.suffix}\"\n\n        video = str(in_file.resolve())\n        metadata_subs = {'scodec': 'mov_text'} if metadata['codec_name'] == 'h264' else {}\n        ffmpeg_subs_inputs = []\n        for i,lang in enumerate(srtin_files):\n            srtin = srtin_files[lang].name + '.srt'\n            subs[lang].save(srtin)\n            ffmpeg_subs_inputs.append(ffmpeg.input(srtin)['s'])\n            metadata_subs[f'metadata:s:s:{i}'] = \"title=\" + lang\n\n        output_file = str(out_file.resolve())\n        input_ffmpeg = ffmpeg.input(video)\n        input_video = input_ffmpeg['v']\n        input_audio = input_ffmpeg['a']\n        output_ffmpeg = ffmpeg.output(\n            input_video, input_audio, *ffmpeg_subs_inputs, output_file,\n            vcodec='copy', acodec='copy',\n            # scodec='mov_text',\n            **metadata_subs\n        )\n        output_ffmpeg = ffmpeg.overwrite_output(output_ffmpeg)\n        ffmpeg.run(output_ffmpeg)\n    finally:\n        for srtin_file in srtin_files.values():\n            srtin_file.close()\n            os.unlink(srtin_file.name)\n    return str(out_file.resolve())\n</code></pre>"},{"location":"#subsai.models","title":"subsai.models","text":""},{"location":"#subsai.models.abstract_model","title":"abstract_model","text":"<p>API that the transcription models should follow</p>"},{"location":"#subsai.models.abstract_model.AbstractModel","title":"AbstractModel","text":"<pre><code>AbstractModel(model_name=None, model_config={})\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Abstract Model class</p> Source code in <code>src/subsai/models/abstract_model.py</code> <pre><code>def __init__(self, model_name=None, model_config={}):\n    self.model_name = model_name\n    self.model_config = model_config\n</code></pre>"},{"location":"#subsai.models.abstract_model.AbstractModel.model_name","title":"model_name  <code>instance-attribute</code>","text":"<pre><code>model_name = model_name\n</code></pre>"},{"location":"#subsai.models.abstract_model.AbstractModel.model_config","title":"model_config  <code>instance-attribute</code>","text":"<pre><code>model_config = model_config\n</code></pre>"},{"location":"#subsai.models.abstract_model.AbstractModel.transcribe","title":"transcribe  <code>abstractmethod</code>","text":"<pre><code>transcribe(media_file)\n</code></pre> <p>Transcribe the <code>media_file</code> to subtitles.</p> <p>example use case from pysubs2.whisper:</p> <p>.. code-block:: python     :linenos:</p> <p>subs = SSAFile() for segment in segments:     event = SSAEvent(start=make_time(s=segment[\"start\"]), end=make_time(s=segment[\"end\"]))     event.plaintext = segment[\"text\"].strip()     subs.append(event)</p> <p>Parameters:</p> <ul> <li> <code>media_file</code>         \u2013          <p>Path of the media file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SSAFile</code>         \u2013          <p>Collection of SSAEvent(s) (see :mod:<code>pysubs2.ssaevent</code>)</p> </li> </ul> Source code in <code>src/subsai/models/abstract_model.py</code> <pre><code>@abstractmethod\ndef transcribe(self, media_file) -&gt; SSAFile:\n    \"\"\"\n    Transcribe the `media_file` to subtitles.\n\n    example use case from pysubs2.whisper:\n\n    .. code-block:: python\n        :linenos:\n\n    subs = SSAFile()\n    for segment in segments:\n        event = SSAEvent(start=make_time(s=segment[\"start\"]), end=make_time(s=segment[\"end\"]))\n        event.plaintext = segment[\"text\"].strip()\n        subs.append(event)\n\n    :param media_file: Path of the media file\n    :return: Collection of SSAEvent(s) (see :mod:`pysubs2.ssaevent`)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model","title":"faster_whisper_model","text":"<p>Faster Whisper Model</p> <p>See guillaumekln/faster-whisper</p>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel","title":"FasterWhisperModel","text":"<pre><code>FasterWhisperModel(model_config)\n</code></pre> <p>             Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/faster_whisper_model.py</code> <pre><code>def __init__(self, model_config):\n    super(FasterWhisperModel, self).__init__(model_config=model_config,\n                                       model_name=self.model_name)\n    # config\n    self._model_size_or_path = _load_config('model_size_or_path', model_config, self.config_schema)\n    self._device = _load_config('device', model_config, self.config_schema)\n    self._device_index = _load_config('device_index', model_config, self.config_schema)\n    self._compute_type = _load_config('compute_type', model_config, self.config_schema)\n    self._cpu_threads = _load_config('cpu_threads', model_config, self.config_schema)\n    self._num_workers = _load_config('num_workers', model_config, self.config_schema)\n\n    self.transcribe_configs = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, f\"_{config}\")}\n\n    self.model = WhisperModel(model_size_or_path=self._model_size_or_path,\n                              device=self._device,\n                              device_index=self._device_index,\n                              compute_type=self._compute_type,\n                              cpu_threads=self._cpu_threads,\n                              num_workers=self._num_workers)\n\n\n    # to show the progress\n    import logging\n\n    logging.basicConfig()\n    logging.getLogger(\"faster_whisper\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'guillaumekln/faster-whisper'\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_size_or_path\": {\n        \"type\": list,\n        \"description\": 'Size of the model to use (e.g. \"large-v2\", \"small\", \"tiny.en\", etc.)or a path to a converted model directory. When a size is configured, the convertedmodel is downloaded from the Hugging Face Hub.',\n        \"options\": whisper.available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": 'Device to use for computation (\"cpu\", \"cuda\", \"auto\")',\n        \"options\": [\"auto\", \"cpu\", \"cuda\"],\n        \"default\": \"auto\",\n    },\n    \"device_index\": {\n        \"type\": int,\n        \"description\": \"Device ID to use.The model can also be loaded on multiple GPUs by passing a list of IDs(e.g. [0, 1, 2, 3]). In that case, multiple transcriptions can run in parallelwhen transcribe() is called from multiple Python threads (see also num_workers).\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"compute_type\": {\n        \"type\": str,\n        \"description\": \"Type to use for computation.See https://opennmt.net/CTranslate2/quantization.html.\",\n        \"options\": None,\n        \"default\": \"default\",\n    },\n    \"cpu_threads\": {\n        \"type\": int,\n        \"description\": \"Number of threads to use when running on CPU (4 by default).A non zero value overrides the OMP_NUM_THREADS environment variable.\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"num_workers\": {\n        \"type\": int,\n        \"description\": \"When transcribe() is called from multiple Python threads,having multiple workers enables true parallelism when running the model(concurrent calls to self.model.generate() will run in parallel).This can improve the global throughput at the cost of increased memory usage.\",\n        \"options\": None,\n        \"default\": 1,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"log_prob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": 5,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": 5,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"prefix\": {\n        \"type\": str,\n        \"description\": \"text or tokens to prefix the current context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"this will suppress blank outputs\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_tokens\": {\n        \"type\": Tuple,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": [-1],\n    },\n    \"without_timestamps\": {\n        \"type\": bool,\n        \"description\": \"use &lt;|notimestamps|&gt; to sample text tokens only\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_initial_timestamp\": {\n        \"type\": float,\n        \"description\": \"the initial timestamp cannot be later than this\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"initial_prompt\": {\n        \"type\": str,\n        \"description\": \"Optional text to provide as a prompt for the first window.\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"word_timestamps\": {\n        \"type\": bool,\n        \"description\": \"Extract word-level timestamps using the cross-attention patternand dynamic time warping, and include the timestamps for each word in each segment.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"prepend_punctuations\": {\n        \"type\": str,\n        \"description\": \"If word_timestamps is True, merge these punctuation symbolswith the next word\",\n        \"options\": None,\n        \"default\": \"\\\"'\u201c\u00bf([{-\",\n    },\n    \"append_punctuations\": {\n        \"type\": str,\n        \"description\": \"If word_timestamps is True, merge these punctuation symbolswith the previous word\",\n        \"options\": None,\n        \"default\": \"\\\"'.\u3002,\uff0c!\uff01?\uff1f:\uff1a\u201d)]}\u3001\",\n    },\n    \"vad_filter\": {\n        \"type\": bool,\n        \"description\": \"If True, use the integrated Silero VAD model to filter out parts of the audio without speech.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"vad_parameters\": {\n        \"type\": dict,\n        \"description\": \"Parameters for splitting long audios into speech chunks using silero VAD.\",\n        \"options\": None,\n        \"default\": {\n            \"threshold\": 0.5,\n            \"min_speech_duration_ms\": 250,\n            \"max_speech_duration_s\": float(\"inf\"),\n            \"min_silence_duration_ms\": 2000,\n            \"window_size_samples\": 1024,\n            \"speech_pad_ms\": 400,\n        },\n    },\n}\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.transcribe_configs","title":"transcribe_configs  <code>instance-attribute</code>","text":"<pre><code>transcribe_configs = {\n    config: _load_config(\n        config, model_config, self.config_schema\n    )\n    for config in self.config_schema\n    if not hasattr(self, f\"_{config}\")\n}\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = WhisperModel(\n    model_size_or_path=self._model_size_or_path,\n    device=self._device,\n    device_index=self._device_index,\n    compute_type=self._compute_type,\n    cpu_threads=self._cpu_threads,\n    num_workers=self._num_workers,\n)\n</code></pre>"},{"location":"#subsai.models.faster_whisper_model.FasterWhisperModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/faster_whisper_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    segments, info = self.model.transcribe(media_file, **self.transcribe_configs)\n    subs = SSAFile()\n    total_duration = round(info.duration, 2)  # Same precision as the Whisper timestamps.\n    timestamps = 0.0  # to get the current segments\n    with tqdm(total=total_duration, unit=\" audio seconds\") as pbar:\n        if self.transcribe_configs['word_timestamps']:  # word level timestamps\n            for segment in segments:\n                pbar.update(segment.end - timestamps)\n                timestamps = segment.end\n                if timestamps &lt; info.duration:\n                    pbar.update(info.duration - timestamps)\n                for word in segment.words:\n                    event = SSAEvent(start=pysubs2.make_time(s=word.start), end=pysubs2.make_time(s=word.end))\n                    event.plaintext = word.word.strip()\n                    subs.append(event)\n        else:\n            for segment in segments:\n                pbar.update(segment.end - timestamps)\n                timestamps = segment.end\n                if timestamps &lt; info.duration:\n                    pbar.update(info.duration - timestamps)\n                event = SSAEvent(start=pysubs2.make_time(s=segment.start), end=pysubs2.make_time(s=segment.end))\n                event.plaintext = segment.text.strip()\n                subs.append(event)\n\n    return subs\n</code></pre>"},{"location":"#subsai.models.whisperX_model","title":"whisperX_model","text":"<p>WhisperX Model</p> <p>See m-bain/whisperX</p>"},{"location":"#subsai.models.whisperX_model.WhisperXModel","title":"WhisperXModel","text":"<pre><code>WhisperXModel(model_config)\n</code></pre> <p>             Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisperX_model.py</code> <pre><code>def __init__(self, model_config):\n    super(WhisperXModel, self).__init__(model_config=model_config,\n                                        model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.device = _load_config('device', model_config, self.config_schema)\n    self.compute_type = _load_config('compute_type', model_config, self.config_schema)\n    self.download_root = _load_config('download_root', model_config, self.config_schema)\n    self.language = _load_config('language', model_config, self.config_schema)\n    self.segment_type = _load_config('segment_type', model_config, self.config_schema)\n    # transcribe config\n    self.batch_size = _load_config('batch_size', model_config, self.config_schema)\n    self.return_char_alignments = _load_config('return_char_alignments', model_config, self.config_schema)\n    self.speaker_labels = _load_config('speaker_labels', model_config, self.config_schema)\n    self.HF_TOKEN = _load_config('HF_TOKEN', model_config, self.config_schema)\n    self.min_speakers = _load_config('min_speakers', model_config, self.config_schema)\n    self.max_speakers = _load_config('max_speakers', model_config, self.config_schema)\n\n    self.model = whisperx.load_model(self.model_type,\n                                     device=self.device,\n                                     compute_type=self.compute_type,\n                                     download_root=self.download_root,\n                                     language=self.language)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'm-bain/whisperX'\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": whisper.available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": 'Device to use for computation (\"cpu\", \"cuda\")',\n        \"options\": [\"cpu\", \"cuda\"],\n        \"default\": \"cpu\",\n    },\n    \"compute_type\": {\n        \"type\": list,\n        \"description\": \"change to 'int8' if low on GPU mem (may reduce accuracy)\",\n        \"options\": [\"default\", \"float16\", \"int8\"],\n        \"default\": \"default\",\n    },\n    \"download_root\": {\n        \"type\": str,\n        \"description\": \"Path to download the model files; by default, it uses '~/.cache/whisper'\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"segment_type\": {\n        \"type\": list,\n        \"description\": \"Word-level timestamps, Choose here between sentence-level and word-level\",\n        \"options\": [\"sentence\", \"word\"],\n        \"default\": \"sentence\",\n    },\n    \"batch_size\": {\n        \"type\": int,\n        \"description\": \"reduce if low on GPU mem\",\n        \"options\": None,\n        \"default\": 16,\n    },\n    \"return_char_alignments\": {\n        \"type\": bool,\n        \"description\": \"Whether to return char alignments\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"speaker_labels\": {\n        \"type\": bool,\n        \"description\": \"Run Diarization Pipeline\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"HF_TOKEN\": {\n        \"type\": str,\n        \"description\": \"if speaker labels is True, you will need Hugging Face access token to use the diarization models, https://github.com/m-bain/whisperX#speaker-diarization\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"min_speakers\": {\n        \"type\": int,\n        \"description\": \"min speakers\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"max_speakers\": {\n        \"type\": int,\n        \"description\": \"max speakers\",\n        \"options\": None,\n        \"default\": None,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = _load_config(\n    \"device\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.compute_type","title":"compute_type  <code>instance-attribute</code>","text":"<pre><code>compute_type = _load_config(\n    \"compute_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.download_root","title":"download_root  <code>instance-attribute</code>","text":"<pre><code>download_root = _load_config(\n    \"download_root\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language = _load_config(\n    \"language\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.segment_type","title":"segment_type  <code>instance-attribute</code>","text":"<pre><code>segment_type = _load_config(\n    \"segment_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.batch_size","title":"batch_size  <code>instance-attribute</code>","text":"<pre><code>batch_size = _load_config(\n    \"batch_size\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.return_char_alignments","title":"return_char_alignments  <code>instance-attribute</code>","text":"<pre><code>return_char_alignments = _load_config(\n    \"return_char_alignments\",\n    model_config,\n    self.config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.speaker_labels","title":"speaker_labels  <code>instance-attribute</code>","text":"<pre><code>speaker_labels = _load_config(\n    \"speaker_labels\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.HF_TOKEN","title":"HF_TOKEN  <code>instance-attribute</code>","text":"<pre><code>HF_TOKEN = _load_config(\n    \"HF_TOKEN\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.min_speakers","title":"min_speakers  <code>instance-attribute</code>","text":"<pre><code>min_speakers = _load_config(\n    \"min_speakers\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.max_speakers","title":"max_speakers  <code>instance-attribute</code>","text":"<pre><code>max_speakers = _load_config(\n    \"max_speakers\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = whisperx.load_model(\n    self.model_type,\n    device=self.device,\n    compute_type=self.compute_type,\n    download_root=self.download_root,\n    language=self.language,\n)\n</code></pre>"},{"location":"#subsai.models.whisperX_model.WhisperXModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisperX_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    audio = whisperx.load_audio(media_file)\n    result = self.model.transcribe(audio, batch_size=self.batch_size)\n    model_a, metadata = whisperx.load_align_model(language_code=result[\"language\"], device=self.device)\n    result = whisperx.align(result[\"segments\"], model_a, metadata, audio, self.device,\n                            return_char_alignments=self.return_char_alignments)\n    self._clear_gpu()\n    del model_a\n    if self.speaker_labels:\n        diarize_model = whisperx.DiarizationPipeline(use_auth_token=self.HF_TOKEN, device=self.device)\n        diarize_segments = diarize_model(audio, min_speakers=self.min_speakers, max_speakers=self.max_speakers)\n        result = whisperx.assign_word_speakers(diarize_segments, result)\n        self._clear_gpu()\n        del diarize_model\n\n    subs = SSAFile()\n\n    if self.segment_type == 'word':  # word level timestamps\n        for segment in result['segments']:\n            for word in segment['words']:\n                try:\n                    event = SSAEvent(start=pysubs2.make_time(s=word[\"start\"]), end=pysubs2.make_time(s=word[\"end\"]),\n                                     name=segment[\"speaker\"] if self.speaker_labels else \"\")\n                    event.plaintext = word[\"word\"].strip()\n                    subs.append(event)\n                except Exception as e:\n                    logging.warning(f\"Something wrong with {word}\")\n                    logging.warning(e)\n\n    elif self.segment_type == 'sentence':\n        for segment in result['segments']:\n            event = SSAEvent(start=pysubs2.make_time(s=segment[\"start\"]), end=pysubs2.make_time(s=segment[\"end\"]),\n                             name=segment[\"speaker\"] if self.speaker_labels else \"\")\n            event.plaintext = segment[\"text\"].strip()\n            subs.append(event)\n    else:\n        raise Exception(f'Unknown `segment_type` value, it should be one of the following: '\n                        f' {self.config_schema[\"segment_type\"][\"options\"]}')\n    return subs\n</code></pre>"},{"location":"#subsai.models.whisper_model","title":"whisper_model","text":"<p>Whisper Model</p> <p>See openai/whisper</p>"},{"location":"#subsai.models.whisper_model.WhisperModel","title":"WhisperModel","text":"<pre><code>WhisperModel(model_config)\n</code></pre> <p>             Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisper_model.py</code> <pre><code>def __init__(self, model_config):\n    super(WhisperModel, self).__init__(model_config=model_config,\n                                       model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.device = _load_config('device', model_config, self.config_schema)\n    self.download_root = _load_config('download_root', model_config, self.config_schema)\n    self.in_memory = _load_config('in_memory', model_config, self.config_schema)\n\n    self.verbose = _load_config('verbose', model_config, self.config_schema)\n    self.temperature = _load_config('temperature', model_config, self.config_schema)\n    self.compression_ratio_threshold = _load_config('compression_ratio_threshold', model_config, self.config_schema)\n    self.logprob_threshold = _load_config('logprob_threshold', model_config, self.config_schema)\n    self.no_speech_threshold = _load_config('no_speech_threshold', model_config, self.config_schema)\n    self.condition_on_previous_text = _load_config('condition_on_previous_text', model_config, self.config_schema)\n\n    self.decode_options = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, config)}\n\n    self.model = whisper.load_model(name=self.model_type,\n                                    device=self.device,\n                                    download_root=self.download_root,\n                                    in_memory=self.in_memory)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'openai/whisper'\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": whisper.available_models(),\n        \"default\": \"base\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": \"The PyTorch device to put the model into\",\n        \"options\": [None, *get_available_devices()],\n        \"default\": None,\n    },\n    \"download_root\": {\n        \"type\": str,\n        \"description\": \"Path to download the model files; by default, it uses '~/.cache/whisper'\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"in_memory\": {\n        \"type\": bool,\n        \"description\": \"whether to preload the model weights into host memory\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"verbose\": {\n        \"type\": bool,\n        \"description\": \"Whether to display the text being decoded to the console. If True, displays all the details,If False, displays minimal details. If None, does not display anything\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": (0.0, 0.2, 0.4, 0.6, 0.8, 1.0),\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"sample_len\": {\n        \"type\": int,\n        \"description\": \"maximum number of tokens to sample\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prompt\": {\n        \"type\": str,\n        \"description\": \"text or tokens for the previous context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"prefix\": {\n        \"type\": str,\n        \"description\": \"text or tokens to prefix the current context\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"this will suppress blank outputs\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_tokens\": {\n        \"type\": str,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": \"-1\",\n    },\n    \"without_timestamps\": {\n        \"type\": bool,\n        \"description\": \"use &lt;|notimestamps|&gt; to sample text tokens only\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_initial_timestamp\": {\n        \"type\": float,\n        \"description\": \"the initial timestamp cannot be later than this\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"fp16\": {\n        \"type\": bool,\n        \"description\": \"use fp16 for most of the calculation\",\n        \"options\": None,\n        \"default\": True,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = _load_config(\n    \"device\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.download_root","title":"download_root  <code>instance-attribute</code>","text":"<pre><code>download_root = _load_config(\n    \"download_root\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.in_memory","title":"in_memory  <code>instance-attribute</code>","text":"<pre><code>in_memory = _load_config(\n    \"in_memory\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.verbose","title":"verbose  <code>instance-attribute</code>","text":"<pre><code>verbose = _load_config(\n    \"verbose\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature = _load_config(\n    \"temperature\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.compression_ratio_threshold","title":"compression_ratio_threshold  <code>instance-attribute</code>","text":"<pre><code>compression_ratio_threshold = _load_config(\n    \"compression_ratio_threshold\",\n    model_config,\n    self.config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.logprob_threshold","title":"logprob_threshold  <code>instance-attribute</code>","text":"<pre><code>logprob_threshold = _load_config(\n    \"logprob_threshold\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.no_speech_threshold","title":"no_speech_threshold  <code>instance-attribute</code>","text":"<pre><code>no_speech_threshold = _load_config(\n    \"no_speech_threshold\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.condition_on_previous_text","title":"condition_on_previous_text  <code>instance-attribute</code>","text":"<pre><code>condition_on_previous_text = _load_config(\n    \"condition_on_previous_text\",\n    model_config,\n    self.config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.decode_options","title":"decode_options  <code>instance-attribute</code>","text":"<pre><code>decode_options = {\n    config: _load_config(\n        config, model_config, self.config_schema\n    )\n    for config in self.config_schema\n    if not hasattr(self, config)\n}\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = whisper.load_model(\n    name=self.model_type,\n    device=self.device,\n    download_root=self.download_root,\n    in_memory=self.in_memory,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_model.WhisperModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisper_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    audio = whisper.load_audio(media_file)\n    result = self.model.transcribe(audio,\n                                   verbose=self.verbose,\n                                   temperature=self.temperature,\n                                   compression_ratio_threshold=self.compression_ratio_threshold,\n                                   logprob_threshold=self.logprob_threshold,\n                                   no_speech_threshold=self.no_speech_threshold,\n                                   condition_on_previous_text=self.condition_on_previous_text,\n                                   **self.decode_options)\n    subs = pysubs2.load_from_whisper(result)\n    return subs\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model","title":"whisper_timestamped_model","text":"<p>whisper_timestamped</p> <p>See linto-ai/whisper-timestamped</p>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped","title":"WhisperTimeStamped","text":"<pre><code>WhisperTimeStamped(model_config={})\n</code></pre> <p>             Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whisper_timestamped_model.py</code> <pre><code>def __init__(self, model_config={}):\n    super(WhisperTimeStamped, self).__init__(model_config=model_config,\n                                             model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n    self.segment_type = _load_config('segment_type', model_config, self.config_schema)\n    self.device = _load_config('device', model_config, self.config_schema)\n    self.download_root = _load_config('download_root', model_config, self.config_schema)\n    self.in_memory = _load_config('in_memory', model_config, self.config_schema)\n\n    self.verbose = _load_config('verbose', model_config, self.config_schema)\n    self.temperature = _load_config('temperature', model_config, self.config_schema)\n    self.compression_ratio_threshold = _load_config('compression_ratio_threshold', model_config, self.config_schema)\n    self.logprob_threshold = _load_config('logprob_threshold', model_config, self.config_schema)\n    self.no_speech_threshold = _load_config('no_speech_threshold', model_config, self.config_schema)\n    self.condition_on_previous_text = _load_config('condition_on_previous_text', model_config, self.config_schema)\n\n    self.decode_options = \\\n        {config: _load_config(config, model_config, self.config_schema)\n         for config in self.config_schema if not hasattr(self, config)}\n\n    self.model = whisper_timestamped.load_model(name=self.model_type,\n                                                device=self.device,\n                                                download_root=self.download_root,\n                                                in_memory=self.in_memory)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'linto-ai/whisper-timestamped'\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"One of the official model names listed by `whisper.available_models()`, or path to a model checkpoint containing the model dimensions and the model state_dict.\",\n        \"options\": whisper_timestamped.available_models(),\n        \"default\": \"base\",\n    },\n    \"segment_type\": {\n        \"type\": list,\n        \"description\": \"Whisper_timestamps gives the ability to have word-level timestamps, Choose here between sentence-level and word-level\",\n        \"options\": [\"sentence\", \"word\"],\n        \"default\": \"sentence\",\n    },\n    \"device\": {\n        \"type\": list,\n        \"description\": \"The PyTorch device to put the model into\",\n        \"options\": [None, *get_available_devices()],\n        \"default\": None,\n    },\n    \"download_root\": {\n        \"type\": str,\n        \"description\": \"Path to download the model files; by default, it uses '~/.cache/whisper'\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"in_memory\": {\n        \"type\": bool,\n        \"description\": \"whether to preload the model weights into host memory\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"verbose\": {\n        \"type\": bool,\n        \"description\": \"Whether to display the text being decoded to the console. If True, displays all the details,If False, displays minimal details. If None, does not display anything\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"temperature\": {\n        \"type\": Tuple,\n        \"description\": \"Temperature for sampling. It can be a tuple of temperatures, which will be successively used upon failures according to either `compression_ratio_threshold` or `logprob_threshold`.\",\n        \"options\": None,\n        \"default\": (0.0, 0.2, 0.4, 0.6, 0.8, 1.0),\n    },\n    \"compression_ratio_threshold\": {\n        \"type\": float,\n        \"description\": \"If the gzip compression ratio is above this value, treat as failed\",\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_threshold\": {\n        \"type\": float,\n        \"description\": \"If the average log probability over sampled tokens is below this value, treat as failed\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_threshold\": {\n        \"type\": float,\n        \"description\": \"If the no_speech probability is higher than this value AND the average log probability over sampled tokens is below `logprob_threshold`, consider the segment as silent\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"condition_on_previous_text\": {\n        \"type\": bool,\n        \"description\": \"if True, the previous output of the model is provided as a prompt for the next window; disabling may make the text inconsistent across windows, but the model becomes less prone to getting stuck in a failure loop, such as repetition looping or timestamps going out of sync.\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"task\": {\n        \"type\": list,\n        \"description\": \"whether to perform X-&gt;X 'transcribe' or X-&gt;English 'translate'\",\n        \"options\": [\"transcribe\", \"translate\"],\n        \"default\": \"transcribe\",\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": \"language that the audio is in; uses detected language if None\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"sample_len\": {\n        \"type\": int,\n        \"description\": \"maximum number of tokens to sample\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"best_of\": {\n        \"type\": int,\n        \"description\": \"number of independent samples to collect, when t &gt; 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"beam_size\": {\n        \"type\": int,\n        \"description\": \"number of beams in beam search, when t == 0\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"patience\": {\n        \"type\": float,\n        \"description\": \"patience in beam search (https://arxiv.org/abs/2204.05424)\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"'alpha' in Google NMT, None defaults to length norm\",\n        \"options\": None,\n        \"default\": None,\n    },\n    \"suppress_tokens\": {\n        \"type\": str,\n        \"description\": 'list of tokens ids (or comma-separated token ids) to suppress \"-1\" will suppress a set of symbols as defined in `tokenizer.non_speech_tokens()`',\n        \"options\": None,\n        \"default\": \"-1\",\n    },\n    \"fp16\": {\n        \"type\": bool,\n        \"description\": \"use fp16 for most of the calculation\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"remove_punctuation_from_words\": {\n        \"type\": bool,\n        \"description\": \"If False, words will be glued with the next punctuation mark (if any).If True, there will be no punctuation mark in the `words[:]['text']` list.It only affects these strings; This has no influence on the computation of the word confidence, whatever the value of `include_punctuation_in_confidence` is.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"refine_whisper_precision\": {\n        \"type\": float,\n        \"description\": \"How much can we refine Whisper segment positions, in seconds. Must be a multiple of 0.02.\",\n        \"options\": None,\n        \"default\": 0.5,\n    },\n    \"min_word_duration\": {\n        \"type\": float,\n        \"description\": \"Minimum duration of a word, in seconds. If a word is shorter than this, timestamps will be adjusted.\",\n        \"options\": None,\n        \"default\": 0.04,\n    },\n    \"plot_word_alignment\": {\n        \"type\": bool,\n        \"description\": \"Whether to plot the word alignment for each segment. matplotlib must be installed to use this option.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"seed\": {\n        \"type\": int,\n        \"description\": \"Random seed to use for temperature sampling, for the sake of reproducibility.Choose None for unpredictable randomness\",\n        \"options\": None,\n        \"default\": 1234,\n    },\n    \"vad\": {\n        \"type\": bool,\n        \"description\": \"Whether to perform voice activity detection (VAD) on the audio file, to remove silent parts before transcribing with Whisper model. This should decrease hallucinations from the Whisper model.\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"detect_disfluencies\": {\n        \"type\": bool,\n        \"description\": 'Whether to detect disfluencies (i.e. hesitations, filler words, repetitions, corrections, etc.) that Whisper model might have omitted in the transcription. This should make the word timestamp prediction more accurate.And probable disfluencies will be marked as special words \"[*]\"',\n        \"options\": None,\n        \"default\": False,\n    },\n    \"trust_whisper_timestamps\": {\n        \"type\": bool,\n        \"description\": \"Whether to rely on Whisper's timestamps to get approximative first estimate of segment positions (up to refine_whisper_precision).\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"naive_approach\": {\n        \"type\": bool,\n        \"description\": \"Force the naive approach that consists in decoding twice the audio file, once to get the transcription and once with the decoded tokens to get the alignment. Note that this approach is used anyway when beam_size is not None and/or when the temperature is a list with more than one element.\",\n        \"options\": None,\n        \"default\": False,\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.segment_type","title":"segment_type  <code>instance-attribute</code>","text":"<pre><code>segment_type = _load_config(\n    \"segment_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = _load_config(\n    \"device\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.download_root","title":"download_root  <code>instance-attribute</code>","text":"<pre><code>download_root = _load_config(\n    \"download_root\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.in_memory","title":"in_memory  <code>instance-attribute</code>","text":"<pre><code>in_memory = _load_config(\n    \"in_memory\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.verbose","title":"verbose  <code>instance-attribute</code>","text":"<pre><code>verbose = _load_config(\n    \"verbose\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature = _load_config(\n    \"temperature\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.compression_ratio_threshold","title":"compression_ratio_threshold  <code>instance-attribute</code>","text":"<pre><code>compression_ratio_threshold = _load_config(\n    \"compression_ratio_threshold\",\n    model_config,\n    self.config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.logprob_threshold","title":"logprob_threshold  <code>instance-attribute</code>","text":"<pre><code>logprob_threshold = _load_config(\n    \"logprob_threshold\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.no_speech_threshold","title":"no_speech_threshold  <code>instance-attribute</code>","text":"<pre><code>no_speech_threshold = _load_config(\n    \"no_speech_threshold\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.condition_on_previous_text","title":"condition_on_previous_text  <code>instance-attribute</code>","text":"<pre><code>condition_on_previous_text = _load_config(\n    \"condition_on_previous_text\",\n    model_config,\n    self.config_schema,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.decode_options","title":"decode_options  <code>instance-attribute</code>","text":"<pre><code>decode_options = {\n    config: _load_config(\n        config, model_config, self.config_schema\n    )\n    for config in self.config_schema\n    if not hasattr(self, config)\n}\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = whisper_timestamped.load_model(\n    name=self.model_type,\n    device=self.device,\n    download_root=self.download_root,\n    in_memory=self.in_memory,\n)\n</code></pre>"},{"location":"#subsai.models.whisper_timestamped_model.WhisperTimeStamped.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whisper_timestamped_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    audio = whisper_timestamped.load_audio(media_file)\n    results = whisper_timestamped.transcribe(self.model, audio,\n                                             verbose=self.verbose,\n                                             temperature=self.temperature,\n                                             compression_ratio_threshold=self.compression_ratio_threshold,\n                                             logprob_threshold=self.logprob_threshold,\n                                             no_speech_threshold=self.no_speech_threshold,\n                                             condition_on_previous_text=self.condition_on_previous_text,\n                                             **self.decode_options\n                                             )\n    subs = SSAFile()\n    if self.segment_type == 'word':  # word level timestamps\n        for segment in results['segments']:\n            for word in segment['words']:\n                event = SSAEvent(start=pysubs2.make_time(s=word[\"start\"]), end=pysubs2.make_time(s=word[\"end\"]))\n                event.plaintext = word[\"text\"].strip()\n                subs.append(event)\n    elif self.segment_type == 'sentence':\n        for segment in results['segments']:\n            event = SSAEvent(start=pysubs2.make_time(s=segment[\"start\"]), end=pysubs2.make_time(s=segment[\"end\"]))\n            event.plaintext = segment[\"text\"].strip()\n            subs.append(event)\n    else:\n        raise Exception(f'Unknown `segment_type` value, it should be one of the following: '\n                        f' {self.config_schema[\"segment_type\"][\"options\"]}')\n    return subs\n</code></pre>"},{"location":"#subsai.models.whispercpp_model","title":"whispercpp_model","text":"<p>Whisper.cpp Model</p> <p>See whisper.cpp, See pywhispercpp</p>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel","title":"WhisperCppModel","text":"<pre><code>WhisperCppModel(model_config)\n</code></pre> <p>             Bases: <code>AbstractModel</code></p> Source code in <code>src/subsai/models/whispercpp_model.py</code> <pre><code>def __init__(self, model_config):\n    super(WhisperCppModel, self).__init__(model_config=model_config,\n                                       model_name=self.model_name)\n    # config\n    self.model_type = _load_config('model_type', model_config, self.config_schema)\n\n    self.params = {}\n    for config in self.config_schema:\n        if not hasattr(self, config):\n            config_value = _load_config(config, model_config, self.config_schema)\n            if config_value is None:\n                continue\n            self.params[config] = config_value\n\n    self.model = Model(model=self.model_type, **self.params)\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name = 'ggerganov/whisper.cpp'\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.config_schema","title":"config_schema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_schema = {\n    \"model_type\": {\n        \"type\": list,\n        \"description\": \"Available whisper.cpp models\",\n        \"options\": AVAILABLE_MODELS,\n        \"default\": \"base\",\n    },\n    \"n_threads\": {\n        \"type\": int,\n        \"description\": \"Number of threads to allocate for the inferencedefault to min(4, available hardware_concurrency)\",\n        \"options\": None,\n        \"default\": 4,\n    },\n    \"n_max_text_ctx\": {\n        \"type\": int,\n        \"description\": \"max tokens to use from past text as prompt for the decoder\",\n        \"options\": None,\n        \"default\": 16384,\n    },\n    \"offset_ms\": {\n        \"type\": int,\n        \"description\": \"start offset in ms\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"duration_ms\": {\n        \"type\": int,\n        \"description\": \"audio duration to process in ms\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"translate\": {\n        \"type\": bool,\n        \"description\": \"whether to translate the audio to English\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"no_context\": {\n        \"type\": bool,\n        \"description\": \"do not use past transcription (if any) as initial prompt for the decoder\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"single_segment\": {\n        \"type\": bool,\n        \"description\": \"force single segment output (useful for streaming)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"print_special\": {\n        \"type\": bool,\n        \"description\": \"print special tokens (e.g. &lt;SOT&gt;, &lt;EOT&gt;, &lt;BEG&gt;, etc.)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"print_progress\": {\n        \"type\": bool,\n        \"description\": \"print progress information\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"print_realtime\": {\n        \"type\": bool,\n        \"description\": \"print results from within whisper.cpp (avoid it, use callback instead)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"print_timestamps\": {\n        \"type\": bool,\n        \"description\": \"print timestamps for each text segment when printing realtime\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"token_timestamps\": {\n        \"type\": bool,\n        \"description\": \"enable token-level timestamps\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"thold_pt\": {\n        \"type\": float,\n        \"description\": \"timestamp token probability threshold (~0.01)\",\n        \"options\": None,\n        \"default\": 0.01,\n    },\n    \"thold_ptsum\": {\n        \"type\": float,\n        \"description\": \"timestamp token sum probability threshold (~0.01)\",\n        \"options\": None,\n        \"default\": 0.01,\n    },\n    \"max_len\": {\n        \"type\": int,\n        \"description\": \"max segment length in characters\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"split_on_word\": {\n        \"type\": bool,\n        \"description\": \"split on word rather than on token (when used with max_len)\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"max_tokens\": {\n        \"type\": int,\n        \"description\": \"max tokens per segment (0 = no limit)\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"speed_up\": {\n        \"type\": bool,\n        \"description\": \"speed-up the audio by 2x using Phase Vocoder\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"audio_ctx\": {\n        \"type\": int,\n        \"description\": \"overwrite the audio context size (0 = use default)\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"prompt_n_tokens\": {\n        \"type\": int,\n        \"description\": \"tokens to provide to the whisper decoder as initial prompt\",\n        \"options\": None,\n        \"default\": 0,\n    },\n    \"language\": {\n        \"type\": str,\n        \"description\": 'for auto-detection, set to None, \"\" or \"auto\"',\n        \"options\": None,\n        \"default\": \"en\",\n    },\n    \"suppress_blank\": {\n        \"type\": bool,\n        \"description\": \"common decoding parameters\",\n        \"options\": None,\n        \"default\": True,\n    },\n    \"suppress_non_speech_tokens\": {\n        \"type\": bool,\n        \"description\": \"common decoding parameters\",\n        \"options\": None,\n        \"default\": False,\n    },\n    \"temperature\": {\n        \"type\": float,\n        \"description\": \"initial decoding temperature\",\n        \"options\": None,\n        \"default\": 0.0,\n    },\n    \"max_initial_ts\": {\n        \"type\": float,\n        \"description\": \"max_initial_ts\",\n        \"options\": None,\n        \"default\": 1.0,\n    },\n    \"length_penalty\": {\n        \"type\": float,\n        \"description\": \"length_penalty\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"temperature_inc\": {\n        \"type\": float,\n        \"description\": \"temperature_inc\",\n        \"options\": None,\n        \"default\": 0.2,\n    },\n    \"entropy_thold\": {\n        \"type\": float,\n        \"description\": 'similar to OpenAI\\'s \"compression_ratio_threshold\"',\n        \"options\": None,\n        \"default\": 2.4,\n    },\n    \"logprob_thold\": {\n        \"type\": float,\n        \"description\": \"logprob_thold\",\n        \"options\": None,\n        \"default\": -1.0,\n    },\n    \"no_speech_thold\": {\n        \"type\": float,\n        \"description\": \"no_speech_thold\",\n        \"options\": None,\n        \"default\": 0.6,\n    },\n    \"greedy\": {\n        \"type\": dict,\n        \"description\": \"greedy\",\n        \"options\": None,\n        \"default\": {\"best_of\": -1},\n    },\n    \"beam_search\": {\n        \"type\": dict,\n        \"description\": \"beam_search\",\n        \"options\": None,\n        \"default\": {\"beam_size\": -1, \"patience\": -1.0},\n    },\n}\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type = _load_config(\n    \"model_type\", model_config, self.config_schema\n)\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params = {}\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = Model(model=self.model_type, **self.params)\n</code></pre>"},{"location":"#subsai.models.whispercpp_model.WhisperCppModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(media_file)\n</code></pre> Source code in <code>src/subsai/models/whispercpp_model.py</code> <pre><code>def transcribe(self, media_file) -&gt; str:\n    segments = self.model.transcribe(media=media_file)\n    subs = SSAFile()\n    for seg in segments:\n        event = SSAEvent(start=seg.t0*10, end=seg.t1*10)\n        event.plaintext = seg.text.strip()\n        subs.append(event)\n    return subs\n</code></pre>"},{"location":"#subsai.configs","title":"subsai.configs","text":"<p>Configurations file</p>"},{"location":"#subsai.configs.AVAILABLE_MODELS","title":"AVAILABLE_MODELS  <code>module-attribute</code>","text":"<pre><code>AVAILABLE_MODELS = {\n    \"openai/whisper\": {\n        \"class\": WhisperModel,\n        \"description\": \"Whisper is a general-purpose speech recognition model. It is trained on a large dataset of diverse audio and is also a multi-task model that can perform multilingual speech recognition as well as speech translation and language identification.\",\n        \"url\": \"https://github.com/openai/whisper\",\n        \"config_schema\": WhisperModel.config_schema,\n    },\n    \"linto-ai/whisper-timestamped\": {\n        \"class\": WhisperTimeStamped,\n        \"description\": \"Multilingual Automatic Speech Recognition with word-level timestamps and confidence.\",\n        \"url\": \"https://github.com/linto-ai/whisper-timestamped\",\n        \"config_schema\": WhisperTimeStamped.config_schema,\n    },\n    \"ggerganov/whisper.cpp\": {\n        \"class\": WhisperCppModel,\n        \"description\": \"High-performance inference of OpenAI's Whisper automatic speech recognition (ASR) model\\n* Plain C/C++ implementation without dependencies\\n* Runs on the CPU\\n\",\n        \"url\": \"https://github.com/ggerganov/whisper.cpp\\nhttps://github.com/abdeladim-s/pywhispercpp\",\n        \"config_schema\": WhisperCppModel.config_schema,\n    },\n    \"guillaumekln/faster-whisper\": {\n        \"class\": FasterWhisperModel,\n        \"description\": \"**faster-whisper** is a reimplementation of OpenAI's Whisper model using [CTranslate2](https://github.com/OpenNMT/CTranslate2/), which is a fast inference engine for Transformer models.\\nThis implementation is up to 4 times faster than [openai/whisper]( https://github.com/openai/whisper) for the same accuracy while using less memory. The efficiency can be further improved with 8-bit quantization on both CPU and GPU.\",\n        \"url\": \"https://github.com/guillaumekln/faster-whisper\",\n        \"config_schema\": FasterWhisperModel.config_schema,\n    },\n    \"m-bain/whisperX\": {\n        \"class\": WhisperXModel,\n        \"description\": \"**whisperX** is a fast automatic speech recognition (70x realtime with large-v2) with word-level timestamps and speaker diarization.\",\n        \"url\": \"https://github.com/m-bain/whisperX\",\n        \"config_schema\": WhisperXModel.config_schema,\n    },\n}\n</code></pre>"},{"location":"#subsai.configs.BASIC_TOOLS_CONFIGS","title":"BASIC_TOOLS_CONFIGS  <code>module-attribute</code>","text":"<pre><code>BASIC_TOOLS_CONFIGS = {\n    \"set time\": {\n        \"description\": \"Set time to a subtitle\",\n        \"config_schema\": {\n            \"h\": {\n                \"type\": float,\n                \"description\": \"hours: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"m\": {\n                \"type\": float,\n                \"description\": \"minutes: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"s\": {\n                \"type\": float,\n                \"description\": \"seconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"ms\": {\n                \"type\": float,\n                \"description\": \"milliseconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n        },\n    },\n    \"shift\": {\n        \"description\": \"Shift all subtitles by constant time amount\",\n        \"config_schema\": {\n            \"h\": {\n                \"type\": float,\n                \"description\": \"hours: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"m\": {\n                \"type\": float,\n                \"description\": \"minutes: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"s\": {\n                \"type\": float,\n                \"description\": \"seconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"ms\": {\n                \"type\": float,\n                \"description\": \"milliseconds: Integer or float values, may be positive or negative\",\n                \"options\": None,\n                \"default\": 0,\n            },\n            \"frames\": {\n                \"type\": int,\n                \"description\": \"When specified, must be an integer number of frames\",\n                \"options\": None,\n                \"default\": None,\n            },\n            \"fps\": {\n                \"type\": float,\n                \"description\": \"When specified, must be a positive number.\",\n                \"options\": None,\n                \"default\": None,\n            },\n        },\n    },\n}\n</code></pre>"},{"location":"#subsai.configs.ADVANCED_TOOLS_CONFIGS","title":"ADVANCED_TOOLS_CONFIGS  <code>module-attribute</code>","text":"<pre><code>ADVANCED_TOOLS_CONFIGS = {\n    \"ffsubsync\": {\n        \"description\": \"Language-agnostic automatic synchronization of subtitles with video, so that subtitles are aligned to the correct starting point within the video.\",\n        \"url\": \"https://github.com/smacke/ffsubsync\",\n        \"config_schema\": {\n            \"vad\": {\n                \"type\": list,\n                \"description\": \"Which voice activity detector to use for speech extraction (if using video / audio as a reference\",\n                \"options\": [\n                    \"subs_then_webrtc\",\n                    \"webrtc\",\n                    \"subs_then_auditok\",\n                    \"auditok\",\n                    \"subs_then_silero\",\n                    \"silero\",\n                ],\n                \"default\": DEFAULT_VAD,\n            },\n            \"max-subtitle-seconds\": {\n                \"type\": float,\n                \"description\": \"Maximum duration for a subtitle to appear on-screen\",\n                \"options\": None,\n                \"default\": DEFAULT_MAX_SUBTITLE_SECONDS,\n            },\n            \"start-seconds\": {\n                \"type\": int,\n                \"description\": \"Start time for processing\",\n                \"options\": None,\n                \"default\": DEFAULT_START_SECONDS,\n            },\n            \"max-offset-seconds\": {\n                \"type\": float,\n                \"description\": \"The max allowed offset seconds for any subtitle segment\",\n                \"options\": None,\n                \"default\": DEFAULT_MAX_OFFSET_SECONDS,\n            },\n            \"apply-offset-seconds\": {\n                \"type\": float,\n                \"description\": \"Apply a predefined offset in seconds to all subtitle segments\",\n                \"options\": None,\n                \"default\": DEFAULT_APPLY_OFFSET_SECONDS,\n            },\n            \"suppress-output-if-offset-less-than\": {\n                \"type\": float,\n                \"description\": \"Apply a predefined offset in seconds to all subtitle segments\",\n                \"options\": None,\n                \"default\": None,\n            },\n            \"frame-rate\": {\n                \"type\": int,\n                \"description\": \"Frame rate for audio extraction\",\n                \"options\": None,\n                \"default\": DEFAULT_FRAME_RATE,\n            },\n            \"output-encoding\": {\n                \"type\": str,\n                \"description\": 'What encoding to use for writing output subtitles (default=utf-8). Can indicate \"same\" to use same encoding as that of the input.',\n                \"options\": None,\n                \"default\": \"utf-8\",\n            },\n            \"skip-infer-framerate-ratio\": {\n                \"type\": bool,\n                \"description\": \"If set, do not try to infer framerate ratio based on duration ratio.\",\n                \"options\": None,\n                \"default\": False,\n            },\n            \"no-fix-framerate\": {\n                \"type\": bool,\n                \"description\": \"If specified, subsync will not attempt to correct a framerate\",\n                \"options\": None,\n                \"default\": False,\n            },\n            \"serialize-speech\": {\n                \"type\": bool,\n                \"description\": \"If specified, serialize reference speech to a numpy array.\",\n                \"options\": None,\n                \"default\": False,\n            },\n            \"gss\": {\n                \"type\": bool,\n                \"description\": \"If specified, use golden-section search to try to findthe optimal framerate ratio between video and subtitles.\",\n                \"options\": None,\n                \"default\": False,\n            },\n        },\n    },\n    \"Translation\": {\n        \"description\": \"Translate to different languages using AI\",\n        \"url\": \"https://github.com/xhluca/dl-translate\",\n        \"config_schema\": {\n            \"model\": {\n                \"type\": list,\n                \"description\": \"The model\",\n                \"options\": available_translation_models(),\n                \"default\": available_translation_models()[\n                    0\n                ],\n            },\n            \"device\": {\n                \"type\": list,\n                \"description\": '\"cpu\", \"gpu\" or \"auto\". If it\\'s set to \"auto\", will try to select a GPU when available or else fall back to CPU',\n                \"options\": [\n                    \"auto\",\n                    *get_available_devices(),\n                ],\n                \"default\": \"auto\",\n            },\n            \"batch_size\": {\n                \"type\": int,\n                \"description\": \"The number of samples to load at once. If set to `None`, it will process everything at once\\nA smaller value is preferred for `batch_size` if your (video) RAM is limited\",\n                \"options\": None,\n                \"default\": 32,\n            },\n            \"verbose\": {\n                \"type\": bool,\n                \"description\": \"Whether to display the progress bar for every batch processed.\",\n                \"options\": None,\n                \"default\": True,\n            },\n        },\n    },\n}\n</code></pre>"}]}